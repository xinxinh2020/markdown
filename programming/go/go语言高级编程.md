

# 语言基础

## 历史

- 贝尔实验室后来经历了多次动荡，包括Ken Thompson在内的Plan9项目原班人马最终加入了谷歌公司。在Limbo等前辈语言诞生10多年之后，在2007年底，Go语言3个最初的作者因为偶然的因素聚集到一起批斗C++（传说是C++语言的布道师在谷歌公司到处鼓吹C++11各种强大的特性彻底惹恼了他们），他们终于抽出了20%的自由时间创造了Go语言。
- 最初的Go语言规范从2008年3月开始编写，最初的Go程序也是直接编译为C语言，然后再二次编译为机器码
- 到2008年5月，谷歌公司的领导们终于发现了Go语言的巨大潜力，从而开始全力支持这个项目（谷歌的创始人甚至还贡献了func关键字），让他们可以将全部工作时间投入到Go语言的设计和开发中。在Go语言规范初版完成之后，Go语言的编译器终于可以直接生成机器码了
- 2009年01月，Go语言开始采用是否大小写首字母来区分符号是否可以导出
- 2009年11月，正式开源
- 2009年12月，移除了语句末尾的分号



## 基础

- 数组的赋值和函数传参都是以整体复制的方式处理的

- 字符串底层是个只读的字节数组，内容是不可变的，但字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制，因为它底层结构是：

  ```go
  type StringHeader struct {
    Data uintptr
    Len int
  }
  ```

  Data 是一个指针，所以赋值的时候也只需要复制该指针就可以，不需要复制指针对应的整个内容。

- 字符串进行 []byte 和 []rune 强制转换时，可能需要重新分配内存，时间复杂度为 O(n)

- 切片的底层结构：

  ```go
  type SliceHeader struct {
    Data uintptr
    Len int
    Cap int
  }
  ```

- 只有当切片的底层数据指针为空时切片本身才为 nil
- 在切片开头添加元素一般都会导致内存重新分配，并使已有元素都重新复制一次，因此，从切片开头添加元素一般都会比在尾部追加元素性能差很多
- 在判断一个切片是否为空时，一般通过len获取切片的长度来判断，一般很少将切片和nil做直接的比较
- 长时间引用一个切片的一部分会导致整个切片的底层数据无法被回收（如果切片元素是个指针的话，还会导致指针引用的对象无法被回收），如果只对切片的一小部分感兴趣，可以将它们拷到一个新的切片中